{
    "NAME": "Sorting",
    "bubble": {
        "name": "Bubble Sort",
        "informations": {
            "idea": [
                "Iterate through the array multiple times",
                "Each iteration, compare adjacent pairs of elements and swap them if necessary",
                "The largest element {{bubbles up}} to the end of the array after each iteration, similar to bubbles rising to the surface of water"
            ],
            "advantage": [
                "Simple, intuitive, easy to understand",
                "Effective for small arrays",
                "A stable sorting algorithm"
            ],
            "disadvantage": "Poor performance for large arrays",
            "application": [
                "Often used for teaching and illustrating basic sorting algorithms",
                "Sorting small data sets",
                "Checking the correctness of other sorting algorithms"
            ]
        },
        "comments": {
            "cpp": [
                "Declare the function {bbs}",
                "The outer loop allows iterating through the array multiple times to push the largest (ascending order) or smallest (descending order) element to the end of the array",
                "The inner loop compares adjacent pairs of elements and swaps them if they are not in order",
                "Check if two adjacent elements in the array are in the wrong order. If true, these two elements need to be swapped to bring the larger element to the back (ascending order).",
                "Swap two elements"
            ],
            "js": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "{{{cpp,2}}}",
                "{{{cpp,3}}}",
                "{{{cpp,4}}}"
            ],
            "py": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "{{{cpp,2}}}",
                "{{{cpp,3}}}",
                "{{{cpp,4}}}"
            ]
        }
    },
    "selection": {
        "name": "Selection Sort",
        "informations": {
            "idea": [
                "Divide the array into two parts: the sorted part and the unsorted part",
                "Initially, the sorted part is empty and the unsorted part is the entire array",
                "Iterate multiple times, with each iteration, find the smallest (or largest) element in the unsorted part, then swap it with the first element in the unsorted part, expanding the sorted part"
            ],
            "advantage": [
                "Simple, intuitive, easy to understand",
                "Effective for small arrays"
            ],
            "disadvantage": [
                "Poor performance for large arrays",
                "An unstable sorting algorithm"
            ],
            "application": [
                "Sorting small data sets",
                "When memory space is limited",
                "Sorting a small portion of data"
            ]
        },
        "comments": {
            "cpp": [
                "Declare the function {slts}",
                "The outer loop helps iterate through the array multiple times to find and place the smallest or largest element of the unsorted part of the array in its correct position",
                "Initialize the variable {min} to hold the position of the smallest element in the unsorted part of the array",
                "The inner loop is used to find the smallest element in the unsorted part of the array",
                "Check if the element at position {j} is smaller than the element at position {min}. If true, update {min} to hold the position of the current smallest element.",
                "Swap two elements"
            ],
            "js": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "{{{cpp,2}}}",
                "{{{cpp,3}}}",
                "{{{cpp,4}}}",
                "{{{cpp,5}}}"
            ],
            "py": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "{{{cpp,2}}}",
                "{{{cpp,3}}}",
                "{{{cpp,4}}}",
                "Update {min}",
                "{{{cpp,5}}}"
            ]
        }
    },
    "insertion": {
        "name": "Insertion Sort",
        "informations": {
            "idea": [
                "Divide the array into two parts: the sorted part and the unsorted part",
                "Initially, the sorted part contains only the first element, and the rest of the array is the unsorted part",
                "Repeat the process of taking the next element from the unsorted part and inserting it into the correct position in the sorted part"
            ],
            "advantage": [
                "Simple, intuitive, easy to understand",
                "Effective for small arrays",
                "Works well with nearly sorted arrays",
                "A stable sorting algorithm"
            ],
            "disadvantage": "Poor performance for large arrays",
            "application": [
                "Sorting small or nearly sorted data sets",
                "Sorting data in desktop and mobile applications",
                "Intermediate algorithm in more complex algorithms"
            ]
        },
        "comments": {
            "cpp": [
                "Declare the function {ists}",
                "The outer loop to iterate through the positions of the array. The first element is considered sorted.",
                "Initialize {j} to iterate backward through the sorted elements",
                "Initialize {current} to hold the value of the element currently needing a position",
                "The inner loop is used to iterate from right to left, finding the correct position to insert the {current} element into the sorted part of the array. Compare to check if the element at position {j} is greater than {current}, if true, shift the element at {j} to the right to make room for {current}.",
                "Shift the element at position {j} to the right",
                "Insert {current} into the correct position"
            ],
            "js": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "{{{cpp,2}}}",
                "{{{cpp,3}}}",
                "{{{cpp,4}}}",
                "{{{cpp,5}}}",
                "{{{cpp,6}}}"
            ],
            "py": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "Initialize {j} to iterate backward through the sorted elements. Initialize {current} to hold the value of the element currently needing a position.",
                "{{{cpp,4}}}",
                "{{{cpp,5}}}",
                "Decrease {j} to continue iterating left",
                "{{{cpp,6}}}"
            ]
        }
    },
    "quick": {
        "name": "Quick Sort",
        "informations": {
            "idea": [
                "Select an element from the array as the pivot point",
                "Partition the array into two parts: one containing elements smaller than or equal to the pivot and the other containing elements greater than or equal to the pivot",
                "Recursively sort the two subarrays",
                "The sorted subarrays are then combined to form the complete sorted array"
            ],
            "advantage": "Good performance, even with large arrays",
            "disadvantage": "An unstable sorting algorithm",
            "application": [
                "Sorting data in programming languages and libraries",
                "Sorting databases",
                "Used in web and mobile applications",
                "Processing data in distributed algorithms",
                "Analysis and processing of big data"
            ]
        },
        "comments": {
            "cpp": [
                "Declare the function {qs}",
                "If {left} is greater than or equal to {right}, meaning the array segment to be sorted has only one element or no elements left to sort, the function will stop and do nothing further",
                "Initialize {pivot} to store the pivot value as the middle element of the array segment. This element will be used to partition the array segment into two parts.",
                "Initialize {i} to traverse from the beginning to the middle of the array segment, finding elements greater than or equal to the {pivot}",
                "Initialize {j} to traverse from the end to the middle of the array segment, finding elements less than or equal to the {pivot}",
                "Ensure {i} does not exceed {j} during the process of finding and swapping elements",
                "Increase {i} until finding an element greater than or equal to {pivot}",
                "Decrease {j} until finding an element less than or equal to {pivot}",
                "Check again if {i} exceeds {j}",
                "Swap two elements so that the left side contains elements less than or equal to {pivot} and the right side contains elements greater than or equal to {pivot}. Then increase {i} and decrease {j} for the next search.",
                "",
                "Continue sorting the array segment from {left} to {j}",
                "Continue sorting the array segment from {i} to {right}"
            ],
            "js": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "Initialize {jspivot} to store the pivot value as the middle element of the array segment. This element will be used to partition the array segment into two parts.",
                "Initialize {i} to traverse from the beginning to the middle of the array segment, finding elements greater than or equal to {jspivot}",
                "Initialize {j} to traverse from the end to the middle of the array segment, finding elements less than or equal to {jspivot}",
                "{{{cpp,5}}}",
                "Increase {i} until finding an element greater than or equal to {jspivot}",
                "Decrease {j} until finding an element less than or equal to {jspivot}",
                "{{{cpp,8}}}",
                "Swap two elements so that the left side contains elements less than or equal to {jspivot} and the right side contains elements greater than or equal to {jspivot}",
                "Increase {i} for the next search",
                "Decrease {j} for the next search",
                "",
                "",
                "Continue sorting the array segment from {left} to {j}",
                "Continue sorting the array segment from {i} to {right}"
            ],
            "py": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "Exit the function",
                "{{{cpp,2}}}",
                "Initialize {i} to traverse from the beginning to the middle of the array segment, finding elements greater than or equal to {pivot}. Initialize {j} to traverse from the end to the middle of the array segment, finding elements less than or equal to {pivot}.",
                "{{{cpp,5}}}",
                "When {i} has not found an element greater than or equal to {pivot}",
                "Increase {i}",
                "When {j} has not found an element less than or equal to {pivot}",
                "Decrease {j}",
                "{{{cpp,8}}}",
                "Swap two elements so that the left side contains elements less than or equal to {pivot} and the right side contains elements greater than or equal to {pivot}",
                "{{{js,10}}}",
                "{{{js,11}}}",
                "{{{cpp,11}}}",
                "{{{cpp,12}}}"
            ]
        }
    },
    "merge": {
        "name": "Merge Sort",
        "informations": {
            "idea": [
                "The array is divided into smaller parts until each element is considered as a subarray",
                "Each subarray is sorted using recursion",
                "The sorted subarrays are merged into a larger array in order",
                "Repeat the process until the original array is completely sorted"
            ],
            "advantage": [
                "Good performance, even with large arrays",
                "A stable sorting algorithm"
            ],
            "disadvantage": [
                "Not the best algorithm for small arrays"
            ],
            "application": [
                "Sorting data in databases",
                "Sorting lists in web applications",
                "Sorting files",
                "Sorting data in desktop or mobile applications",
                "Sorting data in other algorithms"
            ]
        },
        "comments": {
            "cpp": [
                "Declare the function {merge} to merge two sorted subarrays into one sorted subarray",
                "Calculate the size of the left subarray",
                "Calculate the size of the right subarray",
                "Create a temporary {vector} to store the left subarray",
                "Create a temporary {vector} to store the right subarray",
                "Copy elements from the original array to the left subarray",
                "Copy elements from the original array to the right subarray",
                "Initialize {i} and {j} to traverse for the left and right subarrays",
                "Initialize {k} to traverse for the original array",
                "Merge simultaneously from both subarrays until one of the subarrays runs out of elements",
                "If the current element of the left subarray is less than or equal to the current element of the right subarray, push that element into the original array and increase the indices for both subarrays",
                "Otherwise, push the current element of the right subarray into the original array and increase the indices for both subarrays",
                "Copy the remaining elements of the left subarray into the original array",
                "Copy the remaining elements of the right subarray into the original array",
                "",
                "",
                "Declare the function {ms}",
                "If {left} is greater than or equal to {right}, meaning the array segment to be sorted has only one element or no elements left to sort, the function will stop and do nothing further",
                "Find the middle index of the array",
                "Call recursion to sort the left subarray from {left} to {middle}",
                "Call recursion to sort the right subarray from {middle + 1} to {right}",
                "Call the {merge} function to merge two sorted subarrays into one ordered array"
            ],
            "js": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "{{{cpp,2}}}",
                "Create the left subarray from the original array",
                "Create the right subarray from the original array",
                "{{{cpp,7}}}",
                "{{{cpp,8}}}",
                "{{{cpp,9}}}",
                "{{{cpp,10}}}",
                "{{{cpp,11}}}",
                "{{{cpp,12}}}",
                "{{{cpp,13}}}",
                "{{{cpp,14}}}",
                "{{{cpp,15}}}",
                "{{{cpp,16}}}",
                "{{{cpp,17}}}",
                "{{{cpp,18}}}",
                "Call recursion to sort the left subarray from {left} to {middlejs}",
                "Call recursion to sort the right subarray from {middlejs + 1} to {right}",
                "{{{cpp,21}}}"
            ],
            "py": [
                "{{{cpp,0}}}",
                "{{{cpp,1}}}",
                "{{{cpp,2}}}",
                "{{{js,3}}}",
                "{{{js,4}}}",
                "{{{cpp,7}}}",
                "{{{cpp,8}}}",
                "{{{cpp,9}}}",
                "Check if the current element of the left subarray is less than or equal to the current element of the right subarray. If true, push that element into the original array.",
                "Push the current element of the left subarray into the original array",
                "Increase {i} for the next traversal",
                "Otherwise",
                "Push the current element of the right subarray into the original array",
                "Increase {j} for the next traversal",
                "Increase {k} for the next traversal",
                "Traverse through the remaining elements of the left subarray",
                "Append the remaining elements into the original array",
                "{{{py,10}}}",
                "{{{py,14}}}",
                "Traverse through the remaining elements of the right subarray",
                "{{{py,16}}}",
                "{{{py,10}}}",
                "{{{py,14}}}",
                "",
                "{{{cpp,16}}}",
                "{{{cpp,17}}}",
                "{{{cpp,18}}}",
                "{{{cpp,19}}}",
                "{{{cpp,20}}}",
                "{{{cpp,21}}}"
            ]
        }
    },
    "_": {
        "constraints": [
            "Values separated by whitespace",
            "Values are integers ranging from -9 to 99",
            "Minimum 7 values"
        ]
    }
}